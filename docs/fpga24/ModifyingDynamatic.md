# Modifying Dynamatic

> [!NOTE]
> This exercise, meant to be followed as part of the *Dynamatic Reloaded* workshop @ FPGA'24, is a condensed version of the [*Introduction to Dynamatic* tutorial's second chapter](../Tutorials/Introduction/ModifyingDynamatic.md) that is part of Dynamatic's documentation. To get more insights into everything happening at each step of the exercise, you are invited to check out the full tutorial. All shell commands throughout the exercise must be executed from Dynamatic's top-level directory.

Throughout the exercise, you will see the following two types of blocks.
> [!IMPORTANT]
> *Important* blocks indicate when you need to do something before continuing the exercise.

> [!TIP]
> *Tip* blocks indicate something that you should spend some time exploring on your own to better understand the exercise's content.

In this second exercise, we write a small compiler optimization pass in C++ that transforms dataflow muxes into merges in an attempt to optimize our circuits' area and throughput. We will again use the dataflow visualizer to profile and then debug our circuits.

> [!IMPORTANT]
> All commands for this exercise should be ran from Dynamatic's top-level folder, located at `/home/dynamatic/dynamatic` in the provided virtual machine. You can either use VSCode's integrated terminal, which already opens at the correct location, or open a terminal yourself by clicking the "terminal icon" at the top left of Ubuntu's menu and typing `cd dynamatic` inside of it.   

## Spotting an optimization opportunity

Consider again the [same `loop_multiply` kernel](../../tutorials/Introduction/Ch1/loop_multiply.c) from the previous exercise. See its definition below.

```c
unsigned loop_multiply(in_int_t a[N]) {
  unsigned x = 2;
  for (unsigned i = 0; i < N; ++i) {
    if (a[i] == 0)
      x = x * x;
  }
  return x;
}
```

> [!IMPORTANT]
> (Re-)Open the dataflow visualizer like in the last part of the first exercise using the following command.
> ```sh
> ./bin/dynamatic --run tutorials/Introduction/Ch2/loop-multiply.dyn
> ```

Muxes have an arbitrary number of `data` inputs (here it is always 2) and one `select` input, which selects which valid `data` input gets forwarded to the output. Note that, in general, the `select` input of muxes if generated by the `index` output of the same block's control merge.

> [!TIP]
> Identify all muxes in the circuit and identify which value of the original program each one carries. 

We can write a small compiler pass that will automatically replace all muxes with merges to decrease circuit area and potentially improve performance.

## Testing our pass

For simplicity, the pass has already been added to this branch of Dynamatic. The [full tutorial](../Tutorials/Introduction/ModifyingDynamatic.md#writing-a-small-compiler-pass) details the 5 steps one must follow to create the pass from scratch.

Let's go modify our compilation script---which is called by the frontend's `compile` command---to run the pass as part of the normal synthesis flow.

> [!IMPORTANT]
>  Open [`tools/dynamatic/scripts/compile.sh`](../../tools/dynamatic/scripts/compile.sh) and locate the following two lines (lines 120/121).
> ```sh
> HANDSHAKE_MUX_TO_MERGE=""
> # HANDSHAKE_MUX_TO_MERGE=" --handshake-mux-to-merge "
> ```
> Comment out the first line and uncomment the second one to activate the pass. You should end up with.
> ```sh
> # HANDSHAKE_MUX_TO_MERGE=""
> HANDSHAKE_MUX_TO_MERGE=" --handshake-mux-to-merge "
> ```

Done! The pass has been added to the list of IR transformations Dynamatic performs during compilation.

> [!IMPORTANT]
> Now re-run the same frontend script as before to see the updated circuit. 
> ```sh
> ./bin/dynamatic --run tutorials/Introduction/Ch2/loop-multiply.dyn
> ```

Notice that all muxes have been turned into merges, as expected.

> [!TIP]
> Observe that there are no control merges left in the circuit. Indeed, a control merge is just a merge with an additional `index` output indicating which valid `data` input was selected. The IR no longer uses any of these `index` outputs since muxes have been deleted, so Dynamatic automatically downgraded all control merges to simpler and cheaper merges to save on circuit area. 

Surely this will work on all circuits, which will from now on all be smaller than before, right? 

## A problem

Just to be sure, let's try our optimization on a different yet similar C kernel called [`loop_store`](../../tutorials/Introduction/Ch2/loop_store.c).

```c
// The number of loop iterations
#define N 8

// The kernel under consideration
void loop_store(inout_int_t a[N]) {
  for (unsigned i = 0; i < N; ++i) {
    unsigned x = i;
    if (a[i] == 0)
      x = x * x;
    a[i] = x;
  }
}
```

This has the same rough structure as our previous example, except that now the kernel stores the squared iteration index in the array at each iteration where the corresponding array element is 0; otherwise it stores the index itself.

> [!IMPORTANT]
> Run the following shell command to synthesize this kernel.
> ```sh
> ./bin/dynamatic --run tutorials/Introduction/Ch2/loop-store.dyn
> ```

Observe the frontend's output when running `simulate`. You should see the following.

```
dynamatic> simulate
[INFO] Built kernel for IO gen.
[INFO] Ran kernel for IO gen.
[INFO] Launching Modelsim simulation
[ERROR COMPARE] Token mismatch: [0x00000000] and [0x00000001] are not equal (at transaction id 0).
[FATAL] Simulation failed
```

That's bad! It means that the content of the kernel's input array `a` was different after execution of the C code and after simulation of the generated VHDL design. Our optimization broke something in the dataflow circuit, yielding an incorrect result.

> [!TIP]
> Compare the content of array `a` after execution of the C kernel (`tutorials/Introduction/Ch2/out/sim/C_OUT/output_a.dat`) and after simulation of the generated circuit (`tutorials/Introduction/Ch2/out/sim/VHDL_OUT/output_a.dat`).

Let's attempt to understand the problem using the dataflow visualizer (which should now be open on the incorrect circuit). As the simulation's output indicates, the array's content is wrong even at the first iteration. We expect 0 to be stored at index 0 but instead we get a 1.

> [!TIP]
> Iterate through the simulation's cycles and locate the first time that the store port (`mc_store0`) transfers a token to the memory controller (`mem_controller0`). Then, from the circuit's structure, infer which input to the `mc_store0` node is the store address, and which is the store data.

We are especially interested in the store's data input, since it is the one feeding incorrect tokens into the array.

> [!TIP]
> Once you have identified the store's data input and the first cycle at which it transfers a token to the memory controller, backtrack through cycles to see where the data token came from. You should notice something that should not be happening there. Remember that this is the first time the store transmits to the memory so the data token is supposed to come from the multiplier (`mul1`) since `a[0] := 0` at the beginning. Also remember that the issue must ultimately come from a merge, since those are the only components we modified with our pass.

## (Optional) Fixing the circuit manually

Let's verify that we are correct by modifying manually the IR that ultimately gets transformed into the dataflow circuit and re-simulating. We will turn back the problematic merge we identified previously into a mux.

> [!IMPORTANT]
> Open the `tutorials/Introduction/Ch2/out/comp/handshake_export.mlir` MLIR file and locate the MLIR operation named `merge10`. It should look like the following.
> ```mlir
> %<dataResult> = merge %<dataOperand1>, %<dataOperand2> {bb = 3 : ui32, name = #handshake.name<"merge10">} : i10
> ```
> As the `name` operation attribute indicates, this is the faulty `merge10` we identified in the visualizer. `%<dataOperand1>` and `%<dataOperand2>` are placeholder names for the two SSA values that make up the merge's inputs, while `%<dataResult>` is a placeholder name for the merge's single output.
> 
> Replace the entire line with an equivalent mux, substituting the placeholder names with the same ones the merge had. 
> ```mlir
> %<dataResult> = mux %muxIndex [%<dataOperand1>, %<dataOperand2>] {bb = 3 : ui32, name = #handshake.name<"my_mux">} : i1, i10
> ```

Before the square brackets is the mux's `select` operand: `%muxIndex`. This SSA value currently does not exist in the IR, since it used to come from block 3's control merge that has since then been downgraded to a simple merge due to its `index` output becoming unused.

> [!IMPORTANT]
> Upgrade the merge back into a control merge. First locate the MLIR operation named `merge2`. It should look like the following.
> ```mlir
> %<controlResult> = merge %<controlOperand1>, %<controlOperand2> {bb = 3 : ui32, name = #handshake.name<"merge2">} : none
> ```
> Similarly than before, `%<controlOperand1>` and `%<controlOperand2>` are placeholder names for the two SSA values that make up this merge's inputs, while `%<controlResult>` is a placeholder name for the merge's single output.
>
> Replace the entire line with an equivalent control merge, substituting the placeholder names with the same ones the merge had.
> ```mlir
> %<controlResult>, %muxIndex = control_merge %<controlOperand1>, %<controlOperand2> {bb = 3 : ui32, name = #handshake.name<"my_control_merge">} : none, i1
> ```

And done! We provide a little shell script that will only run the part of the synthesis flow that comes after this file is generated. It will regenerate the VHDL design from the MLIR file, simulate it, and prepare data for the visualizer.

> [!IMPORTANT]
> From Dynamatic's top-level folder, run the provided shell script.
> ```sh
> ./tutorials/Introduction/Ch2/partial-flow.sh
> ```

You should now see that simulation succeeds!

> [!TIP]
> Study the fixed circuit in the visualizer to confirm that a mux is indeed necessary to ensure proper ordering of data tokens to the store port. 


## Conclusion

As we just saw, our pass does not work in every situation. While it is possible to replace some muxes by merges when there is no risk of token re-ordering, this is not true in general for all merges. You would need to design a proper strategy to identify which muxes can be transformed into simpler merges and which are necessary to ensure correct circuit behavior. If you are interested, come to see Aya's talk in the coming days where she argues that it can be very useful in some cases to give up on order and put merges anyway--but then it is important to fix the rest of the circuit, lest you get the wrong result as we saw.
