# Modifying Dynamatic

> [!IMPORTANT]
> This exercise, meant to be followed as part of the *Dynamatic Reloaded* workshop @ FPGA'24, is a condensed version of the [*Introduction to Dynamatic* tutorial's second chapter](../Tutorials/Introduction/ModifyingDynamatic.md.md) that is part of Dynamatic's documentation. To get more insights into everything happening at each step of the exercise, you are invited to check out the full tutorial. All shell commands throughout the tutorial must be executed from Dynamatic's top-level directory.

This exercise logically follows the [Using Dynamatic](UsingDynamatic.md) exercise, and as such requires that you are already familiar with the concepts touched on in the latter. In this exercise, we write a small compiler optimization pass in C++ that transforms dataflow muxes into merges in an attempt to optimize our circuits' area and throughput.

If you have deleted the data generated by the synthesis flow on this kernel during the previous exercise, you should regenerate it fully by running the following command from Dynamatic's top-level folder.

```sh
./bin/dynamatic --run tutorials/Introduction/ModifyingDynamatic/loop_accumulate.sh
```

## Spotting an optimization opportunity

Let's start by re-considering the [same `loop_accumulate` kernel]([`tutorials/Introduction/UsingDynamatic/loop_accumulate.c`](../../../tutorials/Introduction/UsingDynamatic/loop_accumulate.c)) from the previous tutorial. See its definition below.

```c
// The kernel under consideration
unsigned loop_accumulate(in_int_t a[N]) {
  unsigned x = 2;
  for (unsigned i = 0; i < N; ++i) {
    if (a[i] == 0)
      x = x * x;
  }
  return x;
}
```

Open the generated circuit in the dataflow visualizer (inputs files are located at `tutorials/Introduction/UsingDynamatic/out/visual/loop_accumulate.dot` and `tutorials/Introduction/UsingDynamatic/out/visual/sim.csv`).

```sh
./bin/dataflow-visualizer
```

> [!TIP]
> Identify all muxes in the circuit and derive their purpose in this circuit. Remember that muxes have an arbitrary number of `data` inputs (here it is always 2) and one `select` input, which selects which valid `data` input gets forwarded to the output. Note that, in general, the `select` input of muxes if generated by the `index` output of the same block's control merge. 

We can write a small compiler pass that will automatically replace all muxes with merges to decrease circuit area and potentially improve performance. For simplicity, the pass has already been added to this branch of Dynamatic. The [full tutorial](../Tutorials/Introduction/ModifyingDynamatic.md#writing-a-small-compiler-pass) details the 5 steps one must follow to create the pass from scratch.

## Testing our pass

Let's go modify our compilation script---which is called by the frontend's `compile` command---to run it as part of the normal synthesis flow.

Open [`tools/dynamatic/scripts/compile.sh`](../../../tools/dynamatic/scripts/compile.sh) and locate the following call to Dynamatic's optimizer.

```sh
# handshake transformations
"$DYNAMATIC_OPT_BIN" "$F_HANDSHAKE" \
  --handshake-minimize-lsq-usage \
  --handshake-concretize-index-type="width=32" \
  --handshake-minimize-cst-width --handshake-optimize-bitwidths="legacy" \
  --handshake-materialize --handshake-infer-basic-blocks \
  > "$F_HANDSHAKE_TRANSFORMED"    
exit_on_fail "Failed to apply transformations to handshake" \
  "Applied transformations to handshake"
```

This is a compilation step where we apply a number of optimizations/transformation to our *Handshake*-level IR for performance and correctness, and is thus a perfect place to insert our new pass. Remember that we declared our pass in Tablegen to be associated with the `--handshake-mux-to-merge` optimizer flag. We just have to add the flag to the optimizer call to run our new pass. 

```sh
# handshake transformations
"$DYNAMATIC_OPT_BIN" "$F_HANDSHAKE" \
  --handshake-mux-to-merge \
  --handshake-minimize-lsq-usage \
  --handshake-concretize-index-type="width=32" \
  --handshake-minimize-cst-width --handshake-optimize-bitwidths="legacy" \
  --handshake-materialize --handshake-infer-basic-blocks \
  > "$F_HANDSHAKE_TRANSFORMED"    
exit_on_fail "Failed to apply transformations to handshake" \
  "Applied transformations to handshake"
```

Done! Now re-run the same frontend script and re-open the visualizer to see the updated circuit. 

```sh
./bin/dynamatic --run tutorials/Introduction/ModifyingDynamatic/loop_accumulate.sh
# Frontend output here
./bin/dataflow-visualizer
```

> [!TIP]
> Notice that all muxes have been turned into merges. Also observe that there are no control merges left in the circuit. Indeed, a control merge is just a merge with an additional `index` output indicating which valid `data` input was selected. The IR no longer uses any of these `index` outputs since muxes have been deleted, so Dynamatic automatically downgraded all control merges to simpler and cheaper merges to save on circuit area. 

Surely this will work on all circuits, which will from now on all be smaller than before, right? 

## A problem, and a solution!

Just to be sure, let's try our optimization on a different yet similar C kernel called `loop_store` (source available [here](../../tutorials/Introduction/ModifyingDynamatic/loop_store.c)).

```c
// The number of loop iterations
#define N 10

// The kernel under consideration
void loop_store(inout_int_t a[N]) {
  for (unsigned i = 0; i < N; ++i) {
    unsigned x = i;
    if (a[i] == 0)
      x = x * x;
    a[i] = x;
  }
}
```

This has the same rough structure as our previous example, except that now the kernel stores the squared iteration index in the array at each iteration where the corresponding array element is 0; otherwise it stores the index itself.

Run the following to synthesize this kernel.

```sh
./bin/dynamatic --run tutorials/Introduction/ModifyingDynamatic/loop_store.sh
```

Observe the frontend's output when running `simulate`. You should see the following.

```
dynamatic> simulate
[INFO] Built kernel for IO gen.
[INFO] Ran kernel for IO gen.
[INFO] Launching Modelsim simulation
[ERROR COMPARE] Token mismatch: [0x00000000] and [0x00000001] are not equal (at transaction id 0).
[FATAL] Simulation failed
```

That's bad! It means that the content of the kernel's input array `a` was different after execution of the C code and after simulation of the generated VHDL design for it. Our optimization broke something in the dataflow circuit, yielding an incorrect result.

> [!TIP]
> Compare the content of array `a` after execution of the C kernel (tutorials/Introduction/ModifyingDynamatic/out/sim/C_OUT/output_a.dat) and after simulation of the generated circuit (tutorials/Introduction/ModifyingDynamatic/out/sim/C_OUT/output_a.dat). Observe that array elements look shuffled in the latter with respect to the former.

Let's open the dataflow visualizer on this dataflow circuit and try to find out what happened. The DOT and CSV file for this dataflow circuit are located in `tutorials/Introduction/ModifyingDynamatic/out/visual`.

> [!TIP]
> As the simulation's output indicates, the array's content is wrong even at the first iteration. We expect 0 to be stored in the array but instead we get a 1. To debug this problem, iterate through the simulation's cycles and locate the first time that the store port (`mc_store0`) transfers a token to the memory controller (`mem_controller0`). Then, from the circuit's structure, infer which input to the `mc_store0` node is the store address, and which is the store data.

We are especially interested in the store's data input, since it is the one feeding incorrect tokens into the array.

> [!TIP]
> Once you have identified the store's data input and the first cycle at which it transfers a token to the memory controller, backtrack through cycles to see where the data token came from. You should notice something that should not be happening there. Remember that this is the first time the store transmits to the memory so the data token is supposed to come from the multiplier (`mul1`) since `a[0] := 0` at the beginning. Also remember that the issue must ultimately come from a merge, since those are the only components we modified with our pass.

By replacing the mux previously in the place of `merge10`, we caused data tokens to arrive reordered at the store port, hence creating incorrect writes to memory! This is due to the fact that the loop's throughput is much higher when the if branch is not taken, since the multiplier has a latency of 4 cycles while most of our other components have 0 sequential latency.

## Conclusion

As we just saw, our pass does not work in every situation. While it is possible to replace some muxes by merges when there is no risk of token re-ordering, this is not true in general for all merges. You would need to design a proper strategy to identify which muxes can be transformed into simpler merges and which are necessary to ensure correct circuit behavior. If you are interested, come to see Aya's talk in the coming days where she argues that it can be very useful in some cases to give up on order and put merges anyway--but then it is important to fix the rest of the circuit, lest you get the wrong result as we saw.
